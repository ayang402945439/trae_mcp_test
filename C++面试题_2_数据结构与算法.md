## 二、数据结构与算法

### 1. 数组和链表区别和优缺点
**答案**：
| 特性 | 数组 | 链表 |
|------|------|------|
| 存储方式 | 连续内存空间 | 非连续内存空间，通过指针连接 |
| 访问元素 | O(1)（随机访问） | O(n)（顺序访问） |
| 插入/删除 | O(n)（需要移动元素） | O(1)（只需修改指针，已知位置时） |
| 内存分配 | 静态分配（栈）或动态分配（堆） | 动态分配（堆） |
| 空间效率 | 不需要额外空间存储指针 | 需要额外空间存储指针 |
| 适用场景 | 频繁访问元素，较少插入/删除 | 频繁插入/删除，较少随机访问 |

**示例**：
```cpp
#include <iostream>
#include <vector>  // 动态数组
#include <list>    // 双向链表

int main() {
    // 数组示例
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::cout << "Array (vector) access: " << vec[2] << std::endl;  // O(1)访问
    
    // 链表示例
    std::list<int> lst = {1, 2, 3, 4, 5};
    // 链表不支持随机访问，需要迭代器
    auto it = lst.begin();
    std::advance(it, 2);  // 移动到第3个元素，O(n)时间
    std::cout << "Linked list access: " << *it << std::endl;
    
    return 0;
}

### 2. 快速排序
**答案**：快速排序是一种分治算法，通过选择一个基准元素，将数组分为两部分，左边的元素都小于基准，右边的元素都大于基准，然后递归地对左右两部分进行排序。平均时间复杂度为O(nlogn)，最坏情况为O(n²)。

**示例**：
```cpp
#include <iostream>
#include <vector>

int partition(std::vector<int>& arr, int low, int high) {
    int pivot = arr[high];  // 选择最后一个元素作为基准
    int i = low - 1;        // 小于基准的元素的边界
    
    for (int j = low; j < high; ++j) {
        if (arr[j] <= pivot) {
            ++i;
            std::swap(arr[i], arr[j]);
        }
    }
    
    std::swap(arr[i + 1], arr[high]);
    return i + 1;
}

void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);  // 分区点
        
        // 递归排序左右两部分
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    std::vector<int> arr = {10, 7, 8, 9, 1, 5};
    int n = arr.size();
    
    quickSort(arr, 0, n - 1);
    
    std::cout << "Sorted array: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 3. 堆排序是怎么做的
**答案**：堆排序是一种基于二叉堆数据结构的排序算法。二叉堆是一种完全二叉树，分为最大堆（父节点大于等于子节点）和最小堆（父节点小于等于子节点）。堆排序的步骤如下：
1. 构建最大堆（将数组转换为最大堆）
2. 将堆顶元素与最后一个元素交换
3. 调整堆，使其重新成为最大堆
4. 重复步骤2和3，直到堆的大小为1

**示例**：
```cpp
#include <iostream>
#include <vector>

void heapify(std::vector<int>& arr, int n, int i) {
    int largest = i;       // 初始化最大元素为根节点
    int left = 2 * i + 1;  // 左子节点
    int right = 2 * i + 2; // 右子节点
    
    // 如果左子节点大于根节点
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    
    // 如果右子节点大于当前最大元素
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    
    // 如果最大元素不是根节点
    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        
        // 递归调整受影响的子树
        heapify(arr, n, largest);
    }
}

void heapSort(std::vector<int>& arr) {
    int n = arr.size();
    
    // 构建最大堆
    for (int i = n / 2 - 1; i >= 0; --i) {
        heapify(arr, n, i);
    }
    
    // 逐个提取元素
    for (int i = n - 1; i > 0; --i) {
        // 将当前根节点（最大元素）移动到数组末尾
        std::swap(arr[0], arr[i]);
        
        // 调整剩余元素为最大堆
        heapify(arr, i, 0);
    }
}

int main() {
    std::vector<int> arr = {12, 11, 13, 5, 6, 7};
    heapSort(arr);
    
    std::cout << "Sorted array: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}

### 4. 冒泡排序
**答案**：冒泡排序是一种简单的排序算法，通过重复遍历要排序的数组，比较相邻的两个元素，如果它们的顺序错误就交换它们。遍历数组的工作重复进行，直到没有再需要交换的元素为止。时间复杂度为O(n²)。

**示例**：
```cpp
#include <iostream>
#include <vector>

void bubbleSort(std::vector<int>& arr) {
    int n = arr.size();
    bool swapped;
    
    for (int i = 0; i < n - 1; ++i) {
        swapped = false;
        
        for (int j = 0; j < n - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                std::swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        
        // 如果本轮没有交换，说明已经排序完成
        if (!swapped) {
            break;
        }
    }
}

int main() {
    std::vector<int> arr = {64, 34, 25, 12, 22, 11, 90};
    bubbleSort(arr);
    
    std::cout << "Sorted array: ";
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

### 5. 二叉查找（复杂度）
**答案**：二叉查找（二分查找）是一种在有序数组中查找特定元素的算法。它的基本思想是将目标值与数组中间元素比较，如果相等则找到；如果目标值小于中间元素，则在左半部分查找；否则在右半部分查找。时间复杂度为O(logn)，空间复杂度为O(1)（迭代实现）或O(logn)（递归实现）。

**示例**：
```cpp
#include <iostream>
#include <vector>

// 迭代实现
int binarySearch(const std::vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // 避免整数溢出
        
        if (arr[mid] == target) {
            return mid;  // 找到目标，返回索引
        } else if (arr[mid] < target) {
            left = mid + 1;  // 目标在右半部分
        } else {
            right = mid - 1;  // 目标在左半部分
        }
    }
    
    return -1;  // 未找到目标
}

int main() {
    std::vector<int> arr = {2, 3, 4, 10, 40};
    int target = 10;
    
    int result = binarySearch(arr, target);
    
    if (result != -1) {
        std::cout << "Element found at index: " << result << std::endl;
    } else {
        std::cout << "Element not found" << std::endl;
}
    
    return 0;
}

### 6. 链表反转
**答案**：链表反转是指将链表的节点顺序颠倒过来，原来的头节点变成尾节点，原来的尾节点变成头节点。

**示例**：
```cpp
#include <iostream>

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* curr = head;
    
    while (curr != nullptr) {
        ListNode* nextTemp = curr->next;  // 保存下一个节点
        curr->next = prev;                 // 反转指针
        prev = curr;                       // 移动prev
        curr = nextTemp;                   // 移动curr
    }
    
    return prev;  // 新的头节点
}

void printList(ListNode* head) {
    while (head != nullptr) {
        std::cout << head->val << " ";
        head = head->next;
    }
    std::cout << std::endl;
}

int main() {
    // 创建链表：1->2->3->4->5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);
    
    std::cout << "Original list: ";
    printList(head);
    
    // 反转链表
    head = reverseList(head);
    
    std::cout << "Reversed list: ";
    printList(head);
    
    // 释放内存
    while (head != nullptr) {
        ListNode* temp = head;
        head = head->next;
        delete temp;
    }
    
    return 0;
}

### 7. 计算二叉树层
**答案**：计算二叉树的层数（高度）可以使用递归或迭代的方法。递归方法是分别计算左右子树的高度，然后取最大值加1。

**示例**：
```cpp
#include <iostream>
#include <queue>

struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

// 递归方法计算二叉树高度
int maxDepth(TreeNode* root) {
    if (root == nullptr) {
        return 0;  // 空树高度为0
    }
    
    int leftDepth = maxDepth(root->left);   // 左子树高度
    int rightDepth = maxDepth(root->right); // 右子树高度
    
    return std::max(leftDepth, rightDepth) + 1;  // 当前节点高度为子树高度最大值+1
}

// 迭代方法（层序遍历）计算二叉树高度
int maxDepthIterative(TreeNode* root) {
    if (root == nullptr) {
        return 0;
    }
    
    int depth = 0;
    std::queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();
        
        for (int i = 0; i < levelSize; ++i) {
            TreeNode* node = q.front();
            q.pop();
            
            if (node->left != nullptr) {
                q.push(node->left);
            }
            if (node->right != nullptr) {
                q.push(node->right);
            }
        }
        
        depth++;  // 每处理完一层，深度+1
    }
    
    return depth;
}

int main() {
    // 创建二叉树
    //       1
    //      / \
    //     2   3
    //    / \
    //   4   5
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);
    
    std::cout << "Tree depth (recursive): " << maxDepth(root) << std::endl;
    std::cout << "Tree depth (iterative): " << maxDepthIterative(root) << std::endl;
    
    // 释放内存（简单实现，实际应用中应使用更完整的方法）
    delete root->left->left;
    delete root->left->right;
    delete root->left;
    delete root->right;
    delete root;
    
    return 0;
}
```


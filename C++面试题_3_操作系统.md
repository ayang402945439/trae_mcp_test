## 三、操作系统

### 1. 线程和进程的区别、应用场景
**答案**：
| 特性 | 进程 | 线程 |
|------|------|------|
| 定义 | 资源分配的基本单位 | 调度和执行的基本单位 |
| 资源共享 | 进程间资源独立，通过IPC通信 | 同一进程内的线程共享进程资源 |
| 切换开销 | 较大（需要保存和恢复进程上下文） | 较小（主要保存和恢复线程上下文） |
| 并发性 | 进程间并发执行 | 线程间并发执行，同一进程内线程更高效 |
| 安全性 | 较高（地址空间隔离） | 较低（共享内存，需要同步机制） |

**应用场景**：
- **进程**：需要独立运行的程序（如浏览器、编辑器），或需要隔离资源的任务。
- **线程**：同一程序内的并发任务（如Web服务器处理多个请求，GUI程序的后台计算）。

**示例**：
```cpp
#include <iostream>
#include <thread>

void threadFunction() {
    std::cout << "This is a thread function" << std::endl;
    std::cout << "Thread ID: " << std::this_thread::get_id() << std::endl;
}

int main() {
    std::cout << "Main thread starts" << std::endl;
    std::cout << "Main thread ID: " << std::this_thread::get_id() << std::endl;
    
    // 创建并启动线程
    std::thread t(threadFunction);
    
    // 等待线程结束
    t.join();
    
    std::cout << "Main thread ends" << std::endl;
    
    return 0;
}
```

### 2. 多线程中各种锁，读写锁，互斥锁
**答案**：
- **互斥锁（Mutex）**：确保同一时间只有一个线程可以访问共享资源，用于保护临界区。
- **读写锁（Read-Write Lock）**：允许多个线程同时读取共享资源，但只有一个线程可以写入。适用于读多写少的场景。
- **自旋锁（Spin Lock）**：线程在获取锁时不会睡眠，而是不断尝试获取锁，适用于锁持有时间短的场景。
- **递归锁（Recursive Lock）**：允许同一线程多次获取同一把锁，避免死锁。

**示例（互斥锁）**：
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <vector>

std::vector<int> shared_data;
std::mutex mtx;  // 互斥锁

void addToVector(int value) {
    std::lock_guard<std::mutex> lock(mtx);  // 自动加锁和解锁
    shared_data.push_back(value);
    // 离开作用域时自动解锁
}

int main() {
    std::thread t1(addToVector, 1);
    std::thread t2(addToVector, 2);
    std::thread t3(addToVector, 3);
    
    t1.join();
    t2.join();
    t3.join();
    
    // 打印共享数据
    for (int num : shared_data) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```


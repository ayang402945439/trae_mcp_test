## 四、网络

### 1. TCP和UDP的原理、区别、应用场景
**答案**：
| 特性 | TCP | UDP |
|------|-----|-----|
| 连接类型 | 面向连接（三次握手建立连接） | 无连接 |
| 可靠性 | 可靠（重传、流量控制、拥塞控制） | 不可靠（不保证交付，可能丢失、重复、乱序） |
| 传输速度 | 较慢 | 较快 |
| 数据边界 | 无（字节流） | 有（数据包） |
| 资源消耗 | 较高 | 较低 |
| 应用场景 | 要求可靠传输的场景（如HTTP、FTP、SMTP） | 实时性要求高的场景（如视频流、音频流、DNS） |

**示例（TCP客户端简单示例）**：
```cpp
#include <iostream>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string>

int main() {
    // 创建socket
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == -1) {
        std::cerr << "Failed to create socket" << std::endl;
        return 1;
    }
    
    // 设置服务器地址
    sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(8080);  // 端口
    inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr);  // IP地址
    
    // 连接服务器
    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        std::cerr << "Failed to connect" << std::endl;
        return 1;
    }
    
    // 发送数据
    std::string message = "Hello TCP Server!";
    if (send(sock, message.c_str(), message.size(), 0) == -1) {
        std::cerr << "Failed to send data" << std::endl;
        return 1;
    }
    
    // 接收数据
    char buffer[1024] = {0};
    int bytes_received = recv(sock, buffer, sizeof(buffer), 0);
    if (bytes_received == -1) {
        std::cerr << "Failed to receive data" << std::endl;
        return 1;
    }
    
    std::cout << "Received: " << std::string(buffer, bytes_received) << std::endl;
    
    // 关闭socket
    close(sock);
    
    return 0;
}
```


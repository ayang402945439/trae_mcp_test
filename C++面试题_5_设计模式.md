## 五、设计模式

### 1. 单例模式实现
**答案**：单例模式确保一个类只有一个实例，并提供一个全局访问点。常见的实现方式有饿汉式和懒汉式。

**示例（线程安全的懒汉式单例）**：
```cpp
#include <iostream>
#include <mutex>

class Singleton {
private:
    static Singleton* instance;
    static std::mutex mtx;
    
    // 私有构造函数，防止外部实例化
    Singleton() {
        std::cout << "Singleton instance created" << std::endl;
    }
    
    // 私有析构函数
    ~Singleton() {
        std::cout << "Singleton instance destroyed" << std::endl;
    }
    
    // 禁用拷贝和赋值
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    
public:
    // 获取单例实例
    static Singleton* getInstance() {
        if (instance == nullptr) {  // 双重检查锁定
            std::lock_guard<std::mutex> lock(mtx);
            if (instance == nullptr) {
                instance = new Singleton();
                // 注册析构函数，程序结束时自动释放
                std::atexit([]() {
                    delete instance;
                    instance = nullptr;
                });
            }
        }
        return instance;
    }
    
    void doSomething() {
        std::cout << "Singleton is doing something" << std::endl;
    }
};

// 初始化静态成员
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mtx;

int main() {
    // 获取单例实例
    Singleton* singleton1 = Singleton::getInstance();
    Singleton* singleton2 = Singleton::getInstance();
    
    // 验证是同一个实例
    std::cout << "singleton1 address: " << singleton1 << std::endl;
    std::cout << "singleton2 address: " << singleton2 << std::endl;
    
    singleton1->doSomething();
    
    return 0;
}
```

### 2. 策略模式实现
**答案**：策略模式定义了一系列算法，将它们封装起来，并使它们可以相互替换。策略模式让算法独立于使用它的客户端而变化。

**示例**：
```cpp
#include <iostream>
#include <memory>
#include <string>

// 策略接口
class PaymentStrategy {
public:
    virtual ~PaymentStrategy() = default;
    virtual void pay(int amount) const = 0;
};

// 具体策略：信用卡支付
class CreditCardPayment : public PaymentStrategy {
private:
    std::string cardNumber;
    
public:
    CreditCardPayment(const std::string& number) : cardNumber(number) {}
    
    void pay(int amount) const override {
        std::cout << "Paid " << amount << " using credit card: " << cardNumber << std::endl;
    }
};

// 具体策略：支付宝支付
class AlipayPayment : public PaymentStrategy {
private:
    std::string account;
    
public:
    AlipayPayment(const std::string& acc) : account(acc) {}
    
    void pay(int amount) const override {
        std::cout << "Paid " << amount << " using Alipay: " << account << std::endl;
    }
};

// 上下文类：使用策略的客户端
class ShoppingCart {
private:
    std::unique_ptr<PaymentStrategy> paymentStrategy;
    
public:
    void setPaymentStrategy(std::unique_ptr<PaymentStrategy> strategy) {
        paymentStrategy = std::move(strategy);
    }
    
    void checkout(int amount) const {
        if (paymentStrategy) {
            paymentStrategy->pay(amount);
        } else {
            std::cout << "Please set payment strategy first" << std::endl;
        }
    }
};

int main() {
    ShoppingCart cart;
    
    // 使用信用卡支付
    cart.setPaymentStrategy(std::make_unique<CreditCardPayment>("1234-5678-9012-3456"));
    cart.checkout(100);
    
    // 切换到支付宝支付
    cart.setPaymentStrategy(std::make_unique<AlipayPayment>("user@example.com"));
    cart.checkout(200);
    
    return 0;
}
```

### 3. 责任链模式实现
**答案**：责任链模式创建了一个对象链，请求在这个链上传递，直到有一个对象处理它。责任链模式让多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。

**示例**：
```cpp
#include <iostream>
#include <memory>
#include <string>

// 请求类
class Request {
public:
    enum class Type {
        CONFERENCE,
        PURCHASE,
        LEAVE
    };
    
    Request(Type type, int amount) : requestType(type), amount(amount) {}
    
    Type getType() const { return requestType; }
    int getAmount() const { return amount; }
    
private:
    Type requestType;
    int amount;
};

// 处理者抽象类
class Approver {
protected:
    std::shared_ptr<Approver> successor;
    
public:
    virtual ~Approver() = default;
    
    void setSuccessor(std::shared_ptr<Approver> next) {
        successor = next;
    }
    
    virtual void processRequest(const Request& request) const = 0;
};

// 具体处理者：主管
class Director : public Approver {
public:
    void processRequest(const Request& request) const override {
        if (request.getType() == Request::Type::LEAVE && request.getAmount() <= 3) {
            std::cout << "Director approved leave request for " << request.getAmount() << " days" << std::endl;
        } else if (successor) {
            successor->processRequest(request);
        }
    }
};

// 具体处理者：经理
class Manager : public Approver {
public:
    void processRequest(const Request& request) const override {
        if ((request.getType() == Request::Type::LEAVE && request.getAmount() > 3 && request.getAmount() <= 7) ||
            (request.getType() == Request::Type::PURCHASE && request.getAmount() <= 5000)) {
            std::cout << "Manager approved request";
            if (request.getType() == Request::Type::LEAVE) {
                std::cout << " for " << request.getAmount() << " days leave";
            } else {
                std::cout << " for purchase of " << request.getAmount();
            }
            std::cout << std::endl;
        } else if (successor) {
            successor->processRequest(request);
        }
    }
};

// 具体处理者：CEO
class CEO : public Approver {
public:
    void processRequest(const Request& request) const override {
        if ((request.getType() == Request::Type::LEAVE && request.getAmount() > 7) ||
            (request.getType() == Request::Type::PURCHASE && request.getAmount() > 5000) ||
            request.getType() == Request::Type::CONFERENCE) {
            std::cout << "CEO approved request";
            if (request.getType() == Request::Type::LEAVE) {
                std::cout << " for " << request.getAmount() << " days leave";
            } else if (request.getType() == Request::Type::PURCHASE) {
                std::cout << " for purchase of " << request.getAmount();
            } else {
                std::cout << " for conference";
            }
            std::cout << std::endl;
        } else {
            std::cout << "Request cannot be approved" << std::endl;
        }
    }
};

int main() {
    // 创建责任链
    auto director = std::make_shared<Director>();
    auto manager = std::make_shared<Manager>();
    auto ceo = std::make_shared<CEO>();
    
    director->setSuccessor(manager);
    manager->setSuccessor(ceo);
    
    // 创建请求
    Request leave1(Request::Type::LEAVE, 2);      // 2天请假
    Request leave2(Request::Type::LEAVE, 5);      // 5天请假
    Request leave3(Request::Type::LEAVE, 10);     // 10天请假
    Request purchase1(Request::Type::PURCHASE, 3000);  // 3000元采购
    Request purchase2(Request::Type::PURCHASE, 8000);  // 8000元采购
    Request conference(Request::Type::CONFERENCE, 0);   // 会议请求
    
    // 处理请求
    director->processRequest(leave1);
    director->processRequest(leave2);
    director->processRequest(leave3);
    director->processRequest(purchase1);
    director->processRequest(purchase2);
    director->processRequest(conference);
    
    return 0;
}
```

### 4. 组合模式实现
**答案**：组合模式将对象组合成树形结构以表示"部分-整体"的层次关系。组合模式使得用户对单个对象和组合对象的使用具有一致性。

**示例**：
```cpp
#include <iostream>
#include <memory>
#include <string>
#include <vector>

// 组件抽象类
class FileSystemComponent {
protected:
    std::string name;
    
public:
    FileSystemComponent(const std::string& componentName) : name(componentName) {}
    virtual ~FileSystemComponent() = default;
    
    virtual void add(std::shared_ptr<FileSystemComponent> component) {
        throw std::runtime_error("Cannot add to a non-directory component");
    }
    
    virtual void remove(std::shared_ptr<FileSystemComponent> component) {
        throw std::runtime_error("Cannot remove from a non-directory component");
    }
    
    virtual std::shared_ptr<FileSystemComponent> getChild(int index) {
        throw std::runtime_error("Cannot get child from a non-directory component");
    }
    
    virtual std::string getName() const {
        return name;
    }
    
    virtual void display(int depth = 0) const = 0;
};

// 叶子节点：文件
class File : public FileSystemComponent {
public:
    File(const std::string& fileName) : FileSystemComponent(fileName) {}
    
    void display(int depth = 0) const override {
        std::string indent(depth, '-');
        std::cout << indent << "File: " << name << std::endl;
    }
};

// 组合节点：目录
class Directory : public FileSystemComponent {
private:
    std::vector<std::shared_ptr<FileSystemComponent>> children;
    
public:
    Directory(const std::string& dirName) : FileSystemComponent(dirName) {}
    
    void add(std::shared_ptr<FileSystemComponent> component) override {
        children.push_back(component);
    }
    
    void remove(std::shared_ptr<FileSystemComponent> component) override {
        for (auto it = children.begin(); it != children.end(); ++it) {
            if ((*it)->getName() == component->getName()) {
                children.erase(it);
                return;
            }
        }
    }
    
    std::shared_ptr<FileSystemComponent> getChild(int index) override {
        if (index >= 0 && index < children.size()) {
            return children[index];
        }
        return nullptr;
    }
    
    void display(int depth = 0) const override {
        std::string indent(depth, '-');
        std::cout << indent << "Directory: " << name << std::endl;
        
        for (const auto& child : children) {
            child->display(depth + 2);
        }
    }
};

int main() {
    // 创建根目录
    auto rootDir = std::make_shared<Directory>("root");
    
    // 创建子目录和文件
    auto homeDir = std::make_shared<Directory>("home");
    auto userDir = std::make_shared<Directory>("user");
    auto file1 = std::make_shared<File>("file1.txt");
    auto file2 = std::make_shared<File>("file2.cpp");
    auto documentsDir = std::make_shared<Directory>("documents");
    auto file3 = std::make_shared<File>("report.pdf");
    
    // 构建文件系统结构
    rootDir->add(homeDir);
    homeDir->add(userDir);
    userDir->add(file1);
    userDir->add(file2);
    userDir->add(documentsDir);
    documentsDir->add(file3);
    
    // 显示文件系统结构
    rootDir->display();
    
    return 0;
}
```

### 5. 观察者模式实现
**答案**：观察者模式定义了对象之间的一对多依赖关系，当一个对象状态改变时，所有依赖它的对象都会自动收到通知并更新。观察者模式也被称为发布-订阅模式。

**示例**：
```cpp
#include <iostream>
#include <memory>
#include <string>
#include <vector>

// 前向声明
class Subject;

// 观察者接口
class Observer {
public:
    virtual ~Observer() = default;
    virtual void update(const Subject& subject) = 0;
};

// 主题接口
class Subject {
private:
    std::vector<std::weak_ptr<Observer>> observers;  // 使用weak_ptr避免循环引用
    
public:
    virtual ~Subject() = default;
    
    void attach(std::shared_ptr<Observer> observer) {
        observers.push_back(observer);
    }
    
    void detach(std::shared_ptr<Observer> observer) {
        for (auto it = observers.begin(); it != observers.end(); ) {
            if (auto shared = it->lock()) {
                if (shared == observer) {
                    it = observers.erase(it);
                } else {
                    ++it;
                }
            } else {
                it = observers.erase(it);  // 移除已失效的观察者
            }
        }
    }
    
    void notify() {
        for (auto it = observers.begin(); it != observers.end(); ) {
            if (auto observer = it->lock()) {
                observer->update(*this);
                ++it;
            } else {
                it = observers.erase(it);  // 移除已失效的观察者
            }
        }
    }
    
    virtual std::string getState() const = 0;
    virtual void setState(const std::string& state) = 0;
};

// 具体主题：天气预报站
class WeatherStation : public Subject {
private:
    std::string weatherState;
    
public:
    std::string getState() const override {
        return weatherState;
    }
    
    void setState(const std::string& state) override {
        weatherState = state;
        notify();  // 状态改变时通知所有观察者
    }
};

// 具体观察者：手机天气APP
class PhoneWeatherApp : public Observer {
private:
    std::string appName;
    std::string lastWeatherUpdate;
    
public:
    PhoneWeatherApp(const std::string& name) : appName(name) {}
    
    void update(const Subject& subject) override {
        lastWeatherUpdate = subject.getState();
        display();
    }
    
    void display() const {
        std::cout << appName << " received weather update: " << lastWeatherUpdate << std::endl;
    }
};

// 具体观察者：电视天气预报
class TVWeatherReport : public Observer {
private:
    std::string channelName;
    std::string lastWeatherUpdate;
    
public:
    TVWeatherReport(const std::string& name) : channelName(name) {}
    
    void update(const Subject& subject) override {
        lastWeatherUpdate = subject.getState();
        display();
    }
    
    void display() const {
        std::cout << channelName << " weather report: " << lastWeatherUpdate << std::endl;
    }
};

int main() {
    // 创建主题
    auto weatherStation = std::make_shared<WeatherStation>();
    
    // 创建观察者
    auto phoneApp1 = std::make_shared<PhoneWeatherApp>("MyWeatherApp");
    auto phoneApp2 = std::make_shared<PhoneWeatherApp>("WeatherNow");
    auto tvReport = std::make_shared<TVWeatherReport>("CCTV News");
    
    // 注册观察者
    weatherStation->attach(phoneApp1);
    weatherStation->attach(phoneApp2);
    weatherStation->attach(tvReport);
    
    // 改变天气状态
    weatherStation->setState("Sunny, 25°C");
    std::cout << std::endl;
    
    // 改变天气状态
    weatherStation->setState("Rainy, 18°C");
    std::cout << std::endl;
    
    // 移除一个观察者
    weatherStation->detach(phoneApp2);
    weatherStation->setState("Cloudy, 22°C");
    
    return 0;
}
```

### 6. 模板方法模式实现
**答案**：模板方法模式定义了一个算法的骨架，将一些步骤延迟到子类中。模板方法模式使得子类可以在不改变算法结构的情况下重定义算法的某些特定步骤。

**示例**：
```cpp
#include <iostream>
#include <string>

// 抽象类：定义算法骨架
class BeverageMaking {
protected:
    // 模板方法：定义算法骨架
    void prepareBeverage() {
        boilWater();
        brew();
        pourInCup();
        if (wantCondiments()) {
            addCondiments();
        }
        std::cout << "Beverage is ready!" << std::endl << std::endl;
    }
    
    // 具体方法：算法中的固定步骤
    void boilWater() {
        std::cout << "Boiling water..." << std::endl;
    }
    
    void pourInCup() {
        std::cout << "Pouring into cup..." << std::endl;
    }
    
    // 钩子方法：子类可以覆盖，决定算法中的可选步骤是否执行
    virtual bool wantCondiments() {
        return true;  // 默认添加调料
    }
    
    // 抽象方法：子类必须实现的步骤
    virtual void brew() = 0;
    virtual void addCondiments() = 0;
    
public:
    virtual ~BeverageMaking() = default;
    
    // 公共接口，供客户端调用
    void makeBeverage() {
        prepareBeverage();
    }
};

// 具体子类：咖啡
class CoffeeMaking : public BeverageMaking {
protected:
    void brew() override {
        std::cout << "Brewing coffee grounds..." << std::endl;
    }
    
    void addCondiments() override {
        std::cout << "Adding sugar and milk..." << std::endl;
    }
    
    // 覆盖钩子方法
    bool wantCondiments() override {
        std::string answer;
        std::cout << "Would you like sugar and milk with your coffee? (y/n): ";
        std::cin >> answer;
        return answer == "y" || answer == "Y";
    }
};

// 具体子类：茶
class TeaMaking : public BeverageMaking {
protected:
    void brew() override {
        std::cout << "Steeping the tea bag..." << std::endl;
    }
    
    void addCondiments() override {
        std::cout << "Adding lemon..." << std::endl;
    }
    
    // 覆盖钩子方法
    bool wantCondiments() override {
        std::string answer;
        std::cout << "Would you like lemon with your tea? (y/n): ";
        std::cin >> answer;
        return answer == "y" || answer == "Y";
    }
};

int main() {
    std::cout << "Making coffee:" << std::endl;
    CoffeeMaking coffee;
    coffee.makeBeverage();
    
    std::cout << "Making tea:" << std::endl;
    TeaMaking tea;
    tea.makeBeverage();
    
    return 0;
}

```

